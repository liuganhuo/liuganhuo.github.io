<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/05/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>test</title>
    <url>/2023/05/11/test/</url>
    <content><![CDATA[<h2 id="概述六大组件"><a href="#概述六大组件" class="headerlink" title="概述六大组件"></a>概述六大组件</h2><p>先从<strong>容器</strong>看起</p>
<ul>
<li><code>array</code>：确定分配大小的容器</li>
<li><code>vector</code>：末尾开，即可以从末尾增长的容器</li>
<li><code>deque</code>：两端开口的容器，实际实现通过多组长度相同的连续空间，通过指针穿起来。但是将行为模拟地像连续空间一样，并在deque基础上适配了另外两种容器<ul>
<li><code>stack</code>：栈，对deque进行封装</li>
<li><code>queue</code>：队列，同样进行封装</li>
</ul>
</li>
<li><code>list</code>以及<code>forward-list</code> </li>
<li><code>rb-tree</code>：在此基础上适配了两种容器<ul>
<li><code>set</code></li>
<li><code>map</code></li>
</ul>
</li>
<li><code>hashtable</code>：散列表通过连续空间+列表的方式进行，每当元素各处超出列表长度时，进行扩容在此基础上适配了两种容器<ul>
<li><code>unordered-set</code></li>
<li><code>unordered-map</code></li>
</ul>
</li>
</ul>
<p>接下来是<strong>算法</strong>，在STL的设计上，<strong>算法</strong>与<strong>容器</strong>都是<strong>闭门造车</strong>的，二者之间没有任何交流，为了能让不同的容器在不同的算法上都可以正常运行，需要一座桥————<strong>迭代器</strong></p>
<p>为了让<strong>算法</strong>更好地对<strong>容器</strong>操作，并能够普适，由<strong>容器</strong>自然想到了<strong>迭代器</strong></p>
<p>根据<strong>容器</strong>类型不同，有不同类型的<strong>迭代器</strong>，大致分为五种</p>
<ul>
<li><code>output-iterator</code></li>
<li><code>input-iterator</code></li>
<li><code>forward-iterator</code>：继承了(is a) input-iterator</li>
<li><code>bi-iterator </code>：继承了(is a) forward-iterator</li>
<li><code>randomaccess-iterator</code>：继承了(is a)bi-iterator</li>
</ul>
<p>有了<strong>迭代器</strong>，似乎还是不够的，当<strong>算法</strong>对<strong>容器</strong>进行操作时，<strong>算法</strong>可能想去向<strong>容器</strong>确认：值的类型？迭代器类型？等。因此为了便利地给出这些信息，就有了<strong>萃取器</strong>。同样有五个内容</p>
<ul>
<li><code>iterator_category</code>：迭代器的类型</li>
<li><code>value_type：值的类型</code></li>
<li><code>difference_type</code>：计算距离长度的单位</li>
<li><code>pointer</code>：指针类型</li>
<li><code>reference</code>：引用类型，（可能是在需要返回左值时，需要返回这个）</li>
</ul>
<p><strong>萃取器</strong>通过一系列的<code>泛化</code>与<code>偏特化</code>使得其适应各种类型的<strong>迭代器</strong>与<strong>指针</strong>(迭代器不也是特殊的指针)。</p>
<p>上面这些都是基于已有的内容进行操作，现在要考虑容器初始的分配问题，则需要一个<strong>分配器</strong>来进行move、copy等操作，对数据进行整理。在<strong>迭代器</strong>的初始化中也默认包含了一个alloca</p>
<p>在这些都具备后，已经可以进行一般的、严格符合输入的正常操作了，但是为了提高可拓展行，要使用<strong>适配器</strong>，使得各种不同类型、数目的输入都可以正确地被算法、仿函数等接收，或者对容器的操作进行规定/限制，使其成为带有新特性的容器，<strong>适配器</strong>分为三类：</p>
<ul>
<li><p><code>容器适配器</code>：诸如queue、红黑树等</p>
</li>
<li><p><code>迭代器适配器</code>：诸如insert adapters、reverse adapter 、stream iterator可以对容器的行为进行修改</p>
</li>
<li><p><code>仿函数适配器</code> ： 诸如bind家族等，对仿函数的输入参数进行取反等修改</p>
</li>
</ul>
<p><strong>仿函数</strong>其实也是对通过模板的形式，对（）操作符重载，为什么要这么做呢，主要目的是为了在不增加一个函数传入参数的情况下，对函数中的变量有更多的保存/控制，可以通过实例化一个类模板来手动设定仿函数中某些参数的值，而不再需要通过函数的参数传递进去。</p>
<h2 id="LiteGNUStl结构"><a href="#LiteGNUStl结构" class="headerlink" title="LiteGNUStl结构"></a>LiteGNUStl结构</h2><h4 id="文件（已实现部分）分布"><a href="#文件（已实现部分）分布" class="headerlink" title="文件（已实现部分）分布"></a>文件（已实现部分）分布</h4><table>
<thead>
<tr>
<th>组件</th>
<th>文件</th>
</tr>
</thead>
<tbody><tr>
<td><strong>迭代器</strong></td>
<td><strong>iterator.h、type_traits.h</strong></td>
</tr>
<tr>
<td><strong>容器</strong></td>
<td><strong>vector.h、list.h</strong></td>
</tr>
<tr>
<td><strong>算法</strong></td>
<td><strong>uninitialized.h</strong></td>
</tr>
<tr>
<td><strong>仿函数</strong></td>
<td><strong>functional.h</strong></td>
</tr>
<tr>
<td><strong>分配器</strong></td>
<td><strong>constructor.h</strong> <strong>allocator.h</strong></td>
</tr>
<tr>
<td><strong>适配器</strong></td>
<td></td>
</tr>
</tbody></table>
<h5 id="工具：memory-h"><a href="#工具：memory-h" class="headerlink" title="工具：memory.h"></a>工具：memory.h</h5><h5 id="TODO-list-h-vector-h-type-traits-h-memory-h-iterator-h-functional-h"><a href="#TODO-list-h-vector-h-type-traits-h-memory-h-iterator-h-functional-h" class="headerlink" title="TODO: list.h  vector.h  type_traits.h    memory.h    iterator.h    functional.h"></a>TODO: list.h  vector.h  type_traits.h    memory.h    iterator.h    functional.h</h5>]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
</search>
